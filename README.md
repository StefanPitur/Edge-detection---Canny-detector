# Edge detection: Canny-detector


Developed by John F. Canny in 1986, the Canny edge detection is a multi-stage algorithm that detects the edges on a wide range of objects. The algorithm extrapolates useful structural information and because of that, the algorithm is applied in various computer vision tasks. As mentioned before, this is a multi-stage algorithm so let's step into it.

# Process of Canny edge detection algorithm

1)    Apply Gaussian Filter to the image.
2)    Determine the gradient matrix.
3)    Apply NMS ( Non - Maximum Suppression ) 
4)    Apply Double Threshold to detect potential edges
5)    Hysteresis. Connect the weak edges to their strong neighbour.


# 1) Gaussian Blur

Blurs an image using a Gaussian filter. The edge detection algorithm is very sensitive to image noise. As a result, it is essential to filter it in order to prevent detecting false. How do we do that? Simple, by applying a gaussian kernel using the OpenCV library.

    blured_image = cv2.GaussianBlur(image, (3, 3), 0)
  
The first parameter is the image that we want to apply blur on. The second parameter is a tuple that determine the size of the kernel applied. A 3 by 3 gaussian kernel would look like this:

![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/c1e0a314554ab3663f129961ebd28fec307e74c4)


# 2) Calculating the intensity gradient of the image

The gradient detects the direction and the intensity of the edge by using edge-detection operators. I used the Sobel operator because it is very easy to code and to understand. To detect the change of pixels' intensity we simply apply Sobel filters on both X-axis and Y-axis.  Where is how you calculate the gradients:


![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/d2d3c95c9afd9aca9343a0bef60123ff94263f5f)

At each point, the resulting gradient and angle are calculated using these formulas:

![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/23ae6772c5f58751fc6014b71d6adafb30a31c79) , ![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/b3e4efe0d943867ba795d1a960f36d71c1812880)

# 3) Non Maximum - Suppression (NMS)

Non Maximum - Surpression is an edge-thinning technique. Once the edge direction are calculated we can trace them in the image.  When looking at a pixel there are only four directions when checking the surrounding pixels in a reverse trigonometric direction:
- 0 degrees	 =>	horizontal direction
- 45 degrees	=>	positive diagonal
- 90 degrees	=>	vertical direction
- 135 degrees 	=> 	negative diagonal
![alt text](https://github.com/StefanPitur/Edge-detection---Canny-detector/blob/master/nms.png)

For example we analyze the pixel at (x, y) in the image. We have to approximate angle[x, y] to determine what neighbors  shall we check. The diagram above might help you understand the approximations.

The red area covers the intervals [0, 22.5) and [157.5, 180] => we are looking at pixel (x, y-1) and pixel (x, y+1)

The blue area lies between [22.5 , 67.5) => we are looking at pixel (x-1, y-1) and pixel (x+1, y+1)

The yellow area lies between [67.5,  112.5) => we are looking at pixel (x-1, y) and pixel (x+1, y)

The green area lies between [112.5, 157.5) => we are looking at pixel (x+1, y-1) and pixel (x-1, y+1)

If the current pixel is greater than both of his neighbors then we keep it. As a result, the algorithm gets thinner edges.


# Double Thresholding

After applying non - maximum suppression,  the remaining pixels are a more accurate representation of the real edges, but there are still some pixels left generated by noise and color variations. In order to avoid them, it is mandatory to filter the image. This is accomplished by sorting all pixels into 2 categories (weak and strong).  If a pixel's value is greater than our high threshold we consider it a strong one. If the pixel is brighter than the low threshold but darker  than the high threshold, we consider the pixel to be a weak. Pixels that are smaller than the low threshold are being ignored.

# Edge tracking by hysteresis

Now our image consists of weak pixels and strong pixels. We have to make all true edge pixels strong( even if at the moment they are weak) and all the non edge pixels should be transformed into zeros.  A weak pixel is transformed into a strong one only if it has a strong neighbor on any of the 8 directions. 

I hope this article clarifies every step of the algorithm. If you have any questions or improvements that can be made to my code (because it is not perfect) don't hestinate to contact me :) !

Resourses:

https://en.wikipedia.org/wiki/Canny_edge_detector
https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html
https://homepages.inf.ed.ac.uk/rbf/HIPR2/canny.htm
